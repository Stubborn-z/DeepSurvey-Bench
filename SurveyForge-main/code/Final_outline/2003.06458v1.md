1 Introduction  
1.1 Challenges at Scale  
1.2 Scope: Domain and Literature  
1.3 Overview  
1.4 Reading Guide  

2 Proof Engineering by Example  

3 Why Proof Engineering Matters  
3.1 Proof Engineering for Program Verification  
3.2 Proof Engineering for Other Domains  
3.3 Practical Impact  

4 Foundations and Trusted Bases  
4.1 Proof Assistant Pre-History  
4.2 Proof Assistant Early History  
4.3 Proof Assistant Foundations  
4.4 Trusted Computing Bases of Proofs and Programs  

5 Between the Engineer and the Kernel: Languages and Automation  
5.1 Styles of Automation  
5.2 Automation in Practice  

6 Proof Organization and Scalability  
6.1 Property Specification and Encodings  
6.2 Proof Design Principles  
6.3 High-Level Verification Frameworks  
6.4 Proof Reuse  

7 Practical Proof Development and Evolution  
7.1 User Interfaces and Tooling for User Support  
7.2 Proof Evolution  
7.3 User Productivity and Cost Estimation  
7.4 Mining and Learning from Proof Repositories  

8 Conclusion