1 INTRODUCTION
1.1 A Warm-Up Example
1.2 Challenges in Symbolic Execution
1.3 Related Work
1.4 Organization of the Article

2 SYMBOLIC EXECUTION ENGINES
2.1 Mixing Symbolic and Concrete Execution
2.2 Path Selection
2.3 Symbolic Backward Execution
2.4 Design Principles of Symbolic Executors

3 MEMORY MODEL
3.2 Address Concretization
3.3 Partial Memory Modeling
3.4 Lazy Initialization

4 INTERACTION WITH THE ENVIRONMENT

5 PATH EXPLOSION
5.1 Pruning Unrealizable Paths
5.2 Function and Loop Summarization
5.3 Path Subsumption and Equivalence
5.4 Under-constrained Symbolic Execution
5.5 Exploiting Preconditions and Input Features
5.6 State Merging
5.7 Leveraging Program Analysis and Optimization Techniques

6 CONSTRAINT SOLVING

7 FURTHER DIRECTIONS
7.1 Separation Logic
7.2 Invariants
7.3 Function Summaries
7.4 Program Analysis and Optimization
7.5 Symbolic Computation

8 CONCLUSIONS